import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

/**
 * MED Engine - Secure Offline Image Encoding & Decoding
 * Uses PDF as a container for Base64 data with a verification secret.
 */

const MED_MARKER_START = '[[MED_DATA_START]]';
const MED_MARKER_SECRET = '[[MED_SECRET_HASH]]';
const MED_MARKER_END = '[[MED_DATA_END]]';

export const medEngine = {
    /**
     * Encodes multiple images to a single PDF file
     */
    async encode(imageFiles: File[], secret: string): Promise<Uint8Array> {
        // 1. Convert all Images to Base64
        const base64Array = await Promise.all(imageFiles.map(async (file) => {
            return new Promise<string>((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result as string);
                reader.readAsDataURL(file);
            });
        }));

        // 2. Create a high-quality PDF
        const pdfDoc = await PDFDocument.create();
        const page = pdfDoc.addPage([600, 400]);
        const { height } = page.getSize();
        const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

        // Draw Branding
        page.drawText('MED ENCODER - SECURE FILE', {
            x: 50,
            y: height - 50,
            size: 24,
            font,
            color: rgb(0.4, 0.2, 0.6),
        });

        page.drawText('This is a protected document generated by MED Encoder.', {
            x: 50,
            y: height - 100,
            size: 14,
        });

        page.drawText(`Contains ${imageFiles.length} secure image(s).`, {
            x: 50,
            y: height - 130,
            size: 12,
            color: rgb(0.1, 0.6, 0.1),
        });

        page.drawText('Status: ENCODED & READ-ONLY', {
            x: 50,
            y: height - 160,
            size: 12,
        });

        page.drawText('To decode these images, open this in the MED Encoder App and enter the secret code.', {
            x: 50,
            y: height - 210,
            size: 10,
        });

        const pdfBytes = await pdfDoc.save();

        // 3. Append metadata to the end of the PDF
        const encoder = new TextEncoder();
        const metadata = {
            images: base64Array,
            secret: secret,
            version: '2.0'
        };
        const metadataString = `\n\n${MED_MARKER_START}${JSON.stringify(metadata)}${MED_MARKER_END}\n%%EOF`;
        const metadataBytes = encoder.encode(metadataString);

        const finalPdf = new Uint8Array(pdfBytes.length + metadataBytes.length);
        finalPdf.set(pdfBytes);
        finalPdf.set(metadataBytes, pdfBytes.length);

        return finalPdf;
    },

    /**
     * Decodes images from a PDF file
     */
    async decode(pdfBuffer: ArrayBuffer, providedSecret: string): Promise<string[]> {
        const decoder = new TextDecoder();
        const content = decoder.decode(pdfBuffer);

        if (!content.includes(MED_MARKER_START) || !content.includes(MED_MARKER_END)) {
            throw new Error('This file is not a valid MED Encoded PDF.');
        }

        const dataPart = content.split(MED_MARKER_START)[1].split(MED_MARKER_END)[0];

        try {
            // Try parsing as JSON (New Format)
            const metadata = JSON.parse(dataPart);
            if (metadata.secret !== providedSecret) {
                throw new Error('Incorrect Secret Text. Access Denied.');
            }
            return metadata.images;
        } catch (e: any) {
            if (e.message === 'Incorrect Secret Text. Access Denied.') throw e;

            // Fallback to Old Format
            if (dataPart.includes(MED_MARKER_SECRET)) {
                const [base64Data, storedSecret] = dataPart.split(MED_MARKER_SECRET);
                if (storedSecret !== providedSecret) {
                    throw new Error('Incorrect Secret Text. Access Denied.');
                }
                return [base64Data];
            }
            throw new Error('Failed to parse MED data.');
        }
    },

    /**
     * Encodes plain text using a secret key
     */
    textEncode(text: string, secret: string): string {
        const combined = JSON.stringify({ t: text, s: secret });
        // Simple obfuscation so it's not immediately readable
        const encoded = btoa(unescape(encodeURIComponent(combined)));
        return `MED_TEXT_${encoded}`;
    },

    /**
     * Decodes obfuscated text using a secret key
     */
    textDecode(encodedValue: string, providedSecret: string): string {
        if (!encodedValue.startsWith('MED_TEXT_')) {
            throw new Error('Invalid encoded text format.');
        }
        const encoded = encodedValue.replace('MED_TEXT_', '');
        try {
            const decoded = decodeURIComponent(escape(atob(encoded)));
            const data = JSON.parse(decoded);
            if (data.s !== providedSecret) {
                throw new Error('Incorrect Secret Code.');
            }
            return data.t;
        } catch (e) {
            throw new Error('Failed to decode. Data may be corrupted.');
        }
    }
};

