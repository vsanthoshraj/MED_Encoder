import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

/**
 * MED Engine - Secure Offline Image Encoding & Decoding
 * Uses PDF as a container for Base64 data with a verification secret.
 */

const MED_MARKER_START = '[[MED_DATA_START]]';
const MED_MARKER_SECRET = '[[MED_SECRET_HASH]]';
const MED_MARKER_END = '[[MED_DATA_END]]';

export interface DecodedFile {
    data: string;
    name: string;
    type: string;
}

export const medEngine = {
    /**
     * Encodes multiple files to a single PDF container
     */
    async encode(files: File[], secret: string): Promise<Uint8Array> {
        // 1. Convert all Files to Base64 with Metadata
        const encodedArray = await Promise.all(files.map(async (file) => {
            const data = await new Promise<string>((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result as string);
                reader.readAsDataURL(file);
            });
            return {
                data,
                name: file.name,
                type: file.type
            };
        }));

        // 2. Create a high-quality PDF
        const pdfDoc = await PDFDocument.create();
        const page = pdfDoc.addPage([600, 450]);
        const { height } = page.getSize();
        const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

        // Draw Branding
        page.drawText('MY ENCODER DECODER - SECURE FILE', {
            x: 50,
            y: height - 50,
            size: 24,
            font,
            color: rgb(0.4, 0.2, 0.6),
        });

        page.drawText('This is a protected document generated by My Encoder Decoder.', {
            x: 50,
            y: height - 100,
            size: 13,
        });

        page.drawText(`Contains ${files.length} secure file(s):`, {
            x: 50,
            y: height - 140,
            size: 12,
            color: rgb(0.1, 0.6, 0.1),
        });

        // List files (limit to first 5 for preview)
        files.slice(0, 5).forEach((file, index) => {
            page.drawText(`- ${file.name} (${(file.size / 1024).toFixed(1)} KB)`, {
                x: 60,
                y: height - 170 - (index * 20),
                size: 10,
                color: rgb(0.3, 0.3, 0.3),
            });
        });

        if (files.length > 5) {
            page.drawText(`... and ${files.length - 5} more files.`, {
                x: 60,
                y: height - 170 - (5 * 20),
                size: 10,
                color: rgb(0.3, 0.3, 0.3),
            });
        }

        page.drawText('Status: ENCODED & READ-ONLY', {
            x: 50,
            y: 50,
            size: 12,
        });

        page.drawText('To decode these files, open this in the My Encoder Decoder App and enter the secret code.', {
            x: 50,
            y: 30,
            size: 9,
        });

        const pdfBytes = await pdfDoc.save();

        // 3. Append metadata to the end of the PDF
        const encoder = new TextEncoder();
        const metadata = {
            files: encodedArray,
            secret: secret,
            version: '3.0'
        };
        const metadataString = `\n\n${MED_MARKER_START}${JSON.stringify(metadata)}${MED_MARKER_END}\n%%EOF`;
        const metadataBytes = encoder.encode(metadataString);

        const finalPdf = new Uint8Array(pdfBytes.length + metadataBytes.length);
        finalPdf.set(pdfBytes);
        finalPdf.set(metadataBytes, pdfBytes.length);

        return finalPdf;
    },

    /**
     * Decodes files from a PDF container
     */
    async decode(pdfBuffer: ArrayBuffer, providedSecret: string): Promise<DecodedFile[]> {
        const decoder = new TextDecoder();
        const content = decoder.decode(pdfBuffer);

        if (!content.includes(MED_MARKER_START) || !content.includes(MED_MARKER_END)) {
            throw new Error('This file is not a valid Encoded PDF.');
        }

        const dataPart = content.split(MED_MARKER_START)[1].split(MED_MARKER_END)[0];

        try {
            // Try parsing as JSON (New Format v3.0 or v2.0)
            const metadata = JSON.parse(dataPart);
            if (metadata.secret !== providedSecret) {
                throw new Error('Incorrect Secret Code. Access Denied.');
            }

            if (metadata.files) {
                return metadata.files; // v3.0 format
            } else if (metadata.images) {
                // v2.0 compatibility
                return metadata.images.map((img: string, idx: number) => ({
                    data: img,
                    name: `decoded_file_${idx}.png`,
                    type: 'image/png'
                }));
            }
            throw new Error('Unknown format version.');
        } catch (e: any) {
            if (e.message === 'Incorrect Secret Code. Access Denied.') throw e;

            // Fallback to Old Format (v1.0)
            if (dataPart.includes(MED_MARKER_SECRET)) {
                const [base64Data, storedSecret] = dataPart.split(MED_MARKER_SECRET);
                if (storedSecret !== providedSecret) {
                    throw new Error('Incorrect Secret Code. Access Denied.');
                }
                return [{
                    data: base64Data,
                    name: 'decoded_file.png',
                    type: 'image/png'
                }];
            }
            throw new Error('Failed to parse encoded data.');
        }
    },

    /**
     * Encodes plain text using a secret key
     */
    textEncode(text: string, secret: string): string {
        const combined = JSON.stringify({ t: text, s: secret });
        const encoded = btoa(unescape(encodeURIComponent(combined)));
        return `MED_TEXT_${encoded}`;
    },

    /**
     * Decodes obfuscated text using a secret key
     */
    textDecode(encodedValue: string, providedSecret: string): string {
        if (!encodedValue.startsWith('MED_TEXT_')) {
            throw new Error('Invalid encoded text format.');
        }
        const encoded = encodedValue.replace('MED_TEXT_', '');
        try {
            const decoded = decodeURIComponent(escape(atob(encoded)));
            const data = JSON.parse(decoded);
            if (data.s !== providedSecret) {
                throw new Error('Incorrect Secret Code.');
            }
            return data.t;
        } catch (e) {
            throw new Error('Failed to decode. Data may be corrupted.');
        }
    }
};

