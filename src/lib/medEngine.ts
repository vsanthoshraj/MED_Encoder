import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

/**
 * MED Engine - Secure Offline Image Encoding & Decoding
 * Uses PDF as a container for Base64 data with a verification secret.
 */

const MED_MARKER_START = '[[MED_DATA_START]]';
const MED_MARKER_SECRET = '[[MED_SECRET_HASH]]';
const MED_MARKER_END = '[[MED_DATA_END]]';

export const medEngine = {
    /**
     * Encodes an image to a PDF file
     */
    async encode(imageFile: File, secret: string): Promise<Uint8Array> {
        // 1. Convert Image to Base64
        const base64Data = await new Promise<string>((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result as string);
            reader.readAsDataURL(imageFile);
        });

        // 2. Create a high-quality PDF
        const pdfDoc = await PDFDocument.create();
        const page = pdfDoc.addPage([600, 400]);
        const { height } = page.getSize();
        const font = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

        // Draw Branding
        page.drawText('MED ENCODER - SECURE FILE', {
            x: 50,
            y: height - 50,
            size: 24,
            font,
            color: rgb(0.4, 0.2, 0.6),
        });

        page.drawText('This is a protected document generated by MED Encoder.', {
            x: 50,
            y: height - 100,
            size: 14,
        });

        page.drawText('Status: ENCODED & READ-ONLY', {
            x: 50,
            y: height - 130,
            size: 12,
            color: rgb(0.1, 0.6, 0.1),
        });

        page.drawText('To decode this image, open it in the MED Encoder App and enter the secret code.', {
            x: 50,
            y: height - 180,
            size: 10,
        });

        const pdfBytes = await pdfDoc.save();

        // 3. Append metadata to the end of the PDF with clear newline separation
        const encoder = new TextEncoder();
        const metadataString = `\n\n${MED_MARKER_START}${base64Data}${MED_MARKER_SECRET}${secret}${MED_MARKER_END}\n%%EOF`;
        const metadataBytes = encoder.encode(metadataString);

        const finalPdf = new Uint8Array(pdfBytes.length + metadataBytes.length);
        finalPdf.set(pdfBytes);
        finalPdf.set(metadataBytes, pdfBytes.length);

        return finalPdf;
    },

    /**
     * Decodes an image from a PDF file
     */
    async decode(pdfBuffer: ArrayBuffer, providedSecret: string): Promise<string> {
        const decoder = new TextDecoder();
        const content = decoder.decode(pdfBuffer);

        if (!content.includes(MED_MARKER_START) || !content.includes(MED_MARKER_END)) {
            throw new Error('This file is not a valid MED Encoded PDF.');
        }

        const dataPart = content.split(MED_MARKER_START)[1].split(MED_MARKER_END)[0];
        const [base64Data, storedSecret] = dataPart.split(MED_MARKER_SECRET);

        if (storedSecret !== providedSecret) {
            throw new Error('Incorrect Secret Text. Access Denied.');
        }

        return base64Data;
    }
};
